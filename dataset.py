import pandas as pd
import matplotlib.pyplot as plt

from tqdm import tqdm

import datahandler as dh


def byte_to_byte():

    exe_pairs = dh.pair_safe_and_malware()

    with open("data/datasets/byte_to_byte/byte_to_byte.csv", "w") as f:
        f.write("{},{},{}\n".format("byte1", "byte2", "class"))
        for pair in exe_pairs:
            print(pair)
            safe = dh.exe_to_vector("data/safe/{}".format(pair[0]))
            malware = dh.exe_to_vector("data/malware/{}".format(pair[1]))

            safelen = len(safe)
            malwarelen = len(malware)

            if safelen == malwarelen:
                for i in range(safelen):
                    if i+1 != safelen:
                        
                        if safe[i+1] == malware[i+1]:
                            byte1 = safe[i]
                            byte2 = safe[i+1]
                            label = "0"

                        elif safe[i+1] != malware[i+1]:
                            byte1 = malware[i]
                            byte2 = malware[i+1]
                            label = "1"

                        f.write("{},{},{}\n".format(byte1, byte2, label))

            else:
                print("Safe and malware lengths does not match")


def test_byte_to_byte(path="data/datasets/byte_to_byte/byte_to_byte.csv"):
    df = pd.read_csv(path)
    
    df_safe, df_malware = list(map(lambda x: x[1], list(df.groupby("class"))))
    
    safe = list(map(lambda x: (x[0], x[1]), df_safe.values))
    malware = list(map(lambda x: (x[0], x[1]), df_malware.values))

    #byte_counts = {(156, 255): [3, 6], (187, 87): [4, 5]}

    byte_counts = {}
    for b in tqdm(malware):
        if b in safe:
            if b not in byte_counts.keys():
                byte_counts[b] = [malware.count(b), safe.count(b)]

    
    with open("data/datasets/byte_to_byte/common_bytes.json", "w") as f:
        f.write(str(byte_counts))

    labels = list(map(lambda x: str(x), byte_counts.keys()))
    malware_values, safe_values = list(zip(*list(byte_counts.values())))

    plt.figure(figsize=(18,9))
    plt.xticks(range(len(labels)), labels)
    plt.plot(malware_values, label="malware")
    plt.plot(safe_values, label="safe")
    plt.legend(loc="upper right")
    plt.show()


def bytes_to_bytes(byte_series=16, undersample=False):
    exe_pairs = dh.pair_safe_and_malware()

    with open("data/datasets/bytes_to_bytes/bytes_to_bytes.csv", "w") as f:

        column_f_string = "%s,"*byte_series + "class\n"
        f.write(column_f_string % tuple(map(lambda x: "byte" + str(x), range(byte_series))))

        for pair in exe_pairs:
            print(pair)
            safe = dh.exe_to_vector("data/safe/{}".format(pair[0]))
            malware = dh.exe_to_vector("data/malware/{}".format(pair[1]))

            safelen = len(safe)
            malwarelen = len(malware)

            safe_count = 0
            malware_count = 0
            if safelen == malwarelen:
                for i in range(safelen):
                    is_safe = False
                    is_malware = False

                    all_bytes = []
                    
                    if tuple(safe[i:i+byte_series]) == tuple(malware[i:i+byte_series]):
                        all_bytes = list(safe[i:i+byte_series])
                        label = "0"
                        is_safe = True

                    elif not any(x == y for y, x in zip(list(safe[i:i+byte_series]), list(malware[i:i+byte_series]))):
                        all_bytes = list(malware[i:i+byte_series])
                        label = "1"
                        is_malware = True

                    if len(all_bytes) == byte_series:
                            
                        if undersample:
                            if is_safe:
                                if safe_count > malware_count:
                                    continue

                        all_bytes.append(label)
                        data_f_string = "%s,"*byte_series + "%s\n"
                        f.write(data_f_string % tuple(map(lambda x: str(x), all_bytes)))

                        if is_safe:
                            safe_count += 1

                        if is_malware:
                            malware_count += 1

            else:
                print("Safe and malware lengths does not match")


        



if __name__ == "__main__":
    #byte_to_byte()
    #test_byte_to_byte()
    bytes_to_bytes(undersample=True)
